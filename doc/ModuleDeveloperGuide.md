# Developing a Connected Vision Module

First of all, it is a good idea to build and try out the Demo Server with its example modules before beginning the development of a new module (see [README.md](../README.md)).

## Creating a Module

The easiest starting point for the development of a new module is by copying the Skeleton module from the `Connected Vision Apps` repository (https://github.com/ConnectedVision/connectedvision-apps).

In fact you only need the `def/`, `generate.py` and `moduleStructure.json` and can safely delete the rest from the copied directory.

## Module Self-description
The cornerstone of a Connected Vision module is its self-description located in the module's `def/` directory and comprises of the following files:
- `ModuleDescription.json`
- `InputDescription.json`
- `OutputDescription.json`

### Module Description
`ModuleDescription.json` contains the general specification of the module and a definition of its configuration parameters `params`.

```JSON
{
	"name": "Dummy Module",
	"moduleID": "Dummy",
	"description": "Dummy module for the developer guide" ,
	"version": 0.1,
	"author": "someone@example.com",
	"params":
	{
		"description": "Dummy Parameter",
		"type": "object",
		"properties": {
			"maxValue": {
				"description": "a numeric dummy parameter",
				"unit": "count",
				"type": "integer",
				"required": true,
				"default": 0
			}
		}
	}
}
```


- `name`: long module name
- `moduleID`: unique ID of the module (no whitespaces or special characters)
	- implicitly used as source code file- and class name and part of the REST URL
- `description`: short description of the module's purpose
- `version`: version of the module
- `author`: name and/or email of the module author
- `params`: definition / schema of the module configuration parameters according to [JSON Schema](https://json-schema.org)

### Input- and Output Description
`InputDescription.json` and `OutputDescription.json` contain the definition of the input- and output pins, respectively.
Connected Vision modules receive and provide data via *pins*. A single *pin* provides a logically connected set of data. The same data can be provided by multiple *pins* giving different "views" to the data. (TODO: advanced topics)

There are two types of *pins*:
- *meta-data pins*: are handled by the Connected Vision SDK -> dedicated data classes, storage and pin implementations are generated by the Connected Vision generator
- *binary pins*: can be used to transfer any type of data (e.g. image data, raw audio data, etc.), however the encoding /decoding and general handling of the data has to be implemented by the module developer

```JSON
[
	{
		"name": "Dummy Data",
		"id": "DummyData",
		"description": "dataset for dummy module",
		"type": "application/json",
		"properties": {
			"id": {
				"description": "dataset ID",
				"type": "string",
				"exttype": "id",
				"required": true,
				"unit": "md5"
			},
			"configID": {
				"description": "config ID",
				"type": "string",
				"exttype": "id",
				"required": true,
				"unit": "md5"
			},	
			"timestamp": {
				"description": "dataset timestamp",
				"type": "integer",
				"exttype": "timestamp",
				"required": true,
				"unit": "ms"
			},
			"myData": {
				"description": "sample data output",
				"type": "integer"
			},
			...
		}
	},
	{
		"name": "image source (PNG)",
		"id": "PNG-Image",
		"description": "",
		"type": "image/png",
		"properties": {}
	}
]
```

- `name`: long name of the pin
- `id`: unique ID of the pin (no whitespaces or special characters)
	- used as class name and part of the REST-URL
- `description`: short description of the pin
- `type`: MIME type of the pins data (see: [MIME types](https://en.wikipedia.org/wiki/Media_type))
- `properties`: data definition according to an extended [JSON Schema](https://json-schema.org)
	- all *meta-data pins* **must** have:
		- `id`
		- `configID`
		- `timestamp`


## Generator

After writing the self-description of a module, the `Connected Vision Code Generator` will create
- CMake files
- module skeleton files
- class files for module parameters and pin data
- storage handling of data
- input- and output pins

Execute the generator by calling `python3 generate.py`


## Module Source Code

The most important files of a Connected Vision module are:
- `<*ModuleID*>Module.h / .cpp`: implementation of the [Module Class](#Module-Class)
- `<*ModuleID*>Worker.h / .cpp`: implementation of the [Worker Class](#Worker-Class)

### Module Class
The module class implements the control interface of the module and general data handling functions.
Most of the implementation is done in base-class: `Module_BaseClass.h`
Normally only a few adaptions are necessary within the module class.

#### Stores
Connected Vision provides an abstract interface for both temporary- and permanent data storage and different types of database implementations (*TODO*).
Data storage is handled by the `store` interface.
The `Code Generator` automatically creates `store` implementations for datasets defined in one of the self-description files. 

The `prepareStores()` function sets up the storages for output / result data. 

The most commonly used storage types are:
- ring buffer: used for temporary data (e.g. live data from sensors, live image data from video cameras, etc.)
- SQLite: SQLite DB implementation for persistent storage of the data (e.g. analytic results, reporting data, etc.)

Each output pin has its own store. However, it is possible to implement a virtual store and access the data from a different store (*TODO: advanced topics*).

### Pin Factories
`generateInputPin()` and `generateOutputPin()` are factory functions to create an instance of a pin defined by the `pinID`.
Make sure that all input- and output pins handled by these functions.

*Advanced Topic:* You can use these functions to map different instances of a pin to the same implementation of custom pins or use different configurations depending on the `pinID`.

## Worker Class
The main function of the worker class is the `run()` function. This is where all the (algorithmic) work is done. It is called from within a dedicated worker thread and runs until the work is done (for a typical offline data processing task) or it is stopped via the module API. The Connected Vision framework (module- and worker base classes) takes care of the multi-threaded setup and communication. To avoid typical multi-threading problems it is important to **use the control and communication functions** provided by the framework and **not directly interact with the worker**.

A typical worker starts by preparing an initial status object.

```Cpp
// get status
auto statusStore = this->module.getStatusStore();
auto status = statusStore->getByID(configID)->copy();

// reset status
status->resetStableResults();
// delete previous results
this->module.deleteAllData( configID );

// update status timestamps
status->set_systemTimeProcessing( sysTime() );

// save copy of current state
statusStore->save_copy(status);
```

The next step is to set-up the algorithm.

```Cpp
// read config params
Class_Skeleton_params params;
params.parseJson( this->config->get_params() );
```

Get the input pins of your module and start any predecessor module(s).

```Cpp
// get input pins
auto inputDetectionsPin = boost::dynamic_pointer_cast<InputPin_Skeleton_input_Detections>( this->module.getInputPin( this->config, InputPin_Skeleton_input_Detections::PinID() ) );

// start previous module and get current status
auto inputDetectionsStatus = inputDetectionsPin->start();

// get corresponding output pin ID of previous module
pinID_t inputDetectionsOutputPinID = inputDetectionsPin->getOutputPinID();
// get summary about available data
auto inputDetectionsStableResults = inputDetectionsStatus.find_stableResultsByPinID( inputDetectionsOutputPinID );
```

Get an output store to save the result data.

```Cpp
// get output store
auto outputAverageStore = this->module.storeManagerAverage->getReadWriteStore(configID);
```

Synchronize status with store metadata.

```Cpp
// reset stable results
status->set_stableResultsByPinID( Class_generic_status_stableResults::createFromStore(*outputAverageStore), OutputPin_Skeleton_output_Average::PinID() );
```

Once the preparation is done, the main worker loop follows.

```Cpp
do
{
	// get status from preceding module (connected to input pin)
	inputDetectionsStatus = inputDetectionsPin->getStatus();
	inputDetectionsStableResults = inputDetectionsStatus.find_stableResultsByPinID( inputDetectionsOutputPinID );

	// process all data we got so far and notify WorkerController that we process the next iteration
	for (; index <= inputDetectionsStableResults->getconst_indexEnd() && this->controller.nextIterationStep(); ++index)
	{
		// get Detections data
		auto detections = inputDetectionsPin->getByIndex( index );

		// prepare output objects
		auto outputAverage = outputAverageStore->create();

// TODO --> do some algorithmic work HERE! <--
// YES YOU HAVE TO WRITE SOME CODE YOUR OWN ...!
// NOW IS THE TIME AND HERE IS THE PLACE!

		// save results
		outputAverageStore->save_move( outputAverage );

		// update status
		status->set_stableResultsByPinID( Class_generic_status_stableResults::createFromStore(*outputAverageStore), OutputPin_Skeleton_output_Average::PinID() );
		status->set_systemTimeProcessing( sysTime() );

		// commit status to store
		statusStore->save_copy(status);
	}

} while ( inputDetectionsStatus.is_status_running() && this->controller.intermediateContinueCheck() );
```

Cleanup and save the final status.

```Cpp
// update status
status->set_estimatedFinishTime( sysTime() );
status->set_systemTimeProcessing( sysTime() );

if ( this->controller.intermediateContinueCheck() )
{
	// worker has finished successfully
	status->set_status_finished();
	status->set_progress( 1.0 );
}
else
{
	// worker has been stopped
	status->set_status_stopped();
}

// commit status to store
statusStore->save_copy(status);
```

# Add Module to Demo Server

Finally, you must add your module to the Demo Server.

Add the following lines to `DemoServer/build/cmake/CMakeLists.txt`.

```Cmake
add_subdirectory(../../../<module-directory>/build/cmake <moduleID>)
...
target_link_libraries(${PROJECT_NAME}
	Skeleton
	<module-name>
	CONAN_PKG::ConnectedVision
)
```

Add your new module to `DemoServer/src/main.cpp`.

```C++
// include module
#include "../../<module directory>/src/<moduleID>ModuleFactory.h"

// register module factory
server.registerModule( <moduleID>::<moduleID>ModuleFactory::createModule() );
```

Now you can execute CMake, build and run the Demo Server as described in the [README](../README.md).
